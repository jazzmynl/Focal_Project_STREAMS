---
title: "Water Quality Cleaning"
author: "Sully Riley"
format: html
editor: visual
---

### Import Libraries

```{r}
library(tidyverse)
library(assertthat)
library(vegan)

source("utils.R")
```

## Import Data

```{r}
RAW_DATA_FILE_PATH = "water-quality-raw/"
SHOULD_RUN_ASSERTIONS = T
SHOULD_FILTER_ALL_WQ = T

assert = function(assertion, msg = msg) {
  if(SHOULD_RUN_ASSERTIONS) {
    assert_that(
      assertion,
      msg = msg
    )
  }
}
```

### Water Station Fires

```{r}
water_station_fires_raw = readxl::read_excel(paste(RAW_DATA_FILE_PATH, 'WaterStationSites-3-5-24.xlsx', sep = ''))

water_station_fires = water_station_fires_raw |> 
  # rename all the columns used for analysis
  rename(
    station_code = `StationCode`,
    fire_start = `ALARM_DATE`, 
    fire_contained = `CONT_DATE`, 
    fire_name = `FIRE_NAME`,
    fire_distance = `FireDistance`,
    elevation = `Elevation`,
    near_rank = `NEAR_RANK`
) |> 
  mutate(
    fire_start = ymd(fire_start),
    fire_contained = ymd(fire_contained)
  ) 
```

### Water Stations

```{r}
water_stations = water_station_fires |> 
  select(-c(
    fire_name,
    fire_start,
    fire_contained,
    YEAR_,
    FireSize,
    fire_distance,
    near_rank # not sure about this one
  )) |> unique()

assert(
  water_station_fires_raw$StationCode |> unique() |> length() == water_stations |> nrow(),
  msg = "Columns selected for water station dataframe should uniquely identify water stations"
)
```

### Water Quality

```{r}
water_quality_raw = read_tsv(paste(RAW_DATA_FILE_PATH, "analytes.tsv", sep = ''))

water_quality = water_quality_raw |> rename(
  # rename all the columns used for analysis
  station_code = `StationCode`, 
  analyte = `Analyte`,             
  unit = `Unit`,           
  result = `Result`,        
  sample_date = `SampleDate`, 
  collection_time = `CollectionTime`, 
  ) |>  
  mutate(sample_date_time = mdy_hms(sample_date))

hour(water_quality$sample_date_time) = hour(mdy_hms(water_quality$collection_time))
minute(water_quality$sample_date_time) = minute(mdy_hms(water_quality$collection_time))
second(water_quality$sample_date_time) = second(mdy_hms(water_quality$collection_time))

water_quality = water_quality |> 
  select(-c(sample_date, collection_time))

```

## Clean Data

```{r}
MAX_FIRE_DISTANCE = Inf
DATE_INTERVAL = dmonths(1)
```

1.  Get only water quality for stations that we have data for

```{r}
water_quality = water_quality |> 
  filter(station_code %in% water_station_fires$station_code) 

```

2.  Inspect differences in units

```{r}
water_quality |> group_by(analyte, unit) |> 
  summarise(
    count = n()
  )

water_quality |> group_by(analyte) |> 
  summarise(
    count = n()
  )
```

3.  There are only 29 of 3135 phosphorus measurements that are not mg/L, and since it is dry weight, we can't easily convert, so we'll drop the measurements that are not m/L

```{r}
water_quality = water_quality |> 
  # drop inorganic nitrogen
  filter(analyte != "Nitrogen, Inorganic, Total") |> 
  
  # drop phosphorus with uncommon units
  filter(!(analyte == "Phosphorus as P, Total" & unit != "mg/L")
  )
```

4.  Get selected analytes names

```{r}
analytes_of_interest = water_quality$analyte |> unique()
```

## Create sets of analytes

1.  Fire cutoff

    ```{r}
    water_station_fires = water_station_fires |> 
      filter(fire_distance < 1000)
    ```

2.  Create a site-interval with the desired time interval

    ```{r}
    create_date_dataframe = function(date_interval, water_quality) {
      start_date = min(water_quality$sample_date_time)
      end_date = max(water_quality$sample_date_time)

      day_interval = interval(start_date,end_date)/date_interval
      dates = start_date + 0:day_interval*date_interval
      next_date = dates + date_interval

      
      date_df = as.data.frame(dates) |> 
        rename(interval_start = dates) |> 
        mutate(interval_start = as.Date(interval_start),
               interval_end = as.Date(next_date)) |> 
        mutate(date_interval = interval(interval_start, interval_end)) 
      
      date_df
    }

    get_site_intervals = function(water_stations, dates) {
      station_codes = water_stations |> select(c(station_code)) |> 
      unique()

      tidyr::crossing(station_codes, dates)
    }

    dates = create_date_dataframe(DATE_INTERVAL, water_quality)

    water_station_intervals = get_site_intervals(water_station_fires, dates)
    ```

3.  Use a rolling join to join water quality with most recent fire

    ```{r}
    map_analyte_to_most_recent_fire = function(water_quality, water_station_fires) {
      analytes_with_most_recent_fire = inner_join(
        water_quality |> 
          select(station_code, analyte, unit, sample_date_time, result),
        water_station_fires |> 
          select(station_code, fire_name, fire_start, fire_contained),
        by = join_by(
          station_code,
          closest(sample_date_time >= fire_start)
        )
      ) |> mutate(
        time_since_last_fire = case_when(
          sample_date_time >= fire_contained ~ as.Date(sample_date_time) - fire_contained,
          sample_date_time < fire_contained ~ ddays(0)
        )
      )
      
      analytes_with_most_recent_fire |> 
        rename(
          sample.previous_fire_name = fire_name,
          sample.previous_fire_start = fire_start,
          sample.previous_fire_contained = fire_contained,
          sample.duration_since_last_fire = time_since_last_fire
        )
    }

    water_quality_with_most_recent_fire = map_analyte_to_most_recent_fire(water_quality, water_station_fires)
    ```

4.  rolling join to match water_station interval with most recent fire

    ```{r}

    water_stations_with_recent_fire = inner_join(
        water_station_intervals,
        water_station_fires,
        by = join_by(
          station_code,
          # can get two dates if a fire has the same start day
          closest(interval_start >= fire_start)
        )
      ) |> rename(
        site_interval.previous_fire_start = fire_start,
        site_interval.previous_fire_name = fire_name,
        site_interval.previous_fire_contained = fire_contained
      )
    ```

5.  match water quality measurement with water station / interval. If the water quality measurement has a most recent fire that is more recent than the interval start, set the interval start for that row to the most recent fire, and treat it as a different interval

    ```{r}
    water_quality_for_observation = inner_join(
      water_quality_with_most_recent_fire,
      water_stations_with_recent_fire,
      by = join_by(
        station_code,
        closest(sample_date_time >= interval_start)
      )
    ) |> 
      # Create a new interval when the sample previous fire date is different from the site previous fire date - this happens if there was a fire since the interval started
      mutate(
      interval_start = case_when(
        site_interval.previous_fire_start != sample.previous_fire_start ~ sample.previous_fire_start,
        .default = interval_start
      ),
      site_interval.previous_fire_start = case_when(
        site_interval.previous_fire_start != sample.previous_fire_start ~ sample.previous_fire_start,
        .default = site_interval.previous_fire_start
      )
    )
    ```

6.  Get average analyte per interval

    -   Station code

    -   interval_start

    -   analyte

    ```{r}
    group_water_quality_by = function(water_quality_for_observation) {
      water_quality_for_observation |> 
        group_by(
          station_code,
          date_interval,
          interval_start,
          analyte,
          unit,
        )
    }

    assert(water_quality_for_observation |> 
      group_by(
        station_code, 
        date_interval, 
        interval_start,
        analyte,
      ) |> n_groups() == water_quality_for_observation |> 
      group_water_quality_by() |> n_groups())



    mean_water_quality_for_observation = water_quality_for_observation |> 
      # dropped the ones that are after the interval start for now
      filter(interval_start == int_start(date_interval)) |> 
      group_water_quality_by() |> 
      summarise(
        result = mean(result),
        last_fire_start = unique(site_interval.previous_fire_start),
        last_fire_contained = max(site_interval.previous_fire_contained),
        last_fire_distance = min(fire_distance),
        elevation = unique(elevation),
        near_rank = unique(near_rank)
      ) |> ungroup() |> 
      mutate(
        time_since_last_fire = case_when(
          interval_start > last_fire_contained ~ interval_start - last_fire_contained,
          .default = ddays(0)
        )
      )

    colnames(mean_water_quality_for_observation)

    stations_with_analytes = mean_water_quality_for_observation |> 
      pivot_wider(
        id_cols = c(
          station_code, 
          date_interval, 
          interval_start, 
          last_fire_start, 
          last_fire_contained, 
          time_since_last_fire,
          elevation,
          near_rank,
          last_fire_distance),
        names_from = analyte,
        values_from = result) |> 
      rename(
        phosphorus_mg_l = "Phosphorus as P, Total",
        dissolved_organic_carbon_mg_l = "Dissolved Organic Carbon, Dissolved",
        total_suspended_solids_mg_l = "Total Suspended Solids, Total",
        nitrogen_organic_mg_l = "Nitrogen, Organic, Total"
      ) |> select(
        -c(nitrogen_organic_mg_l, phosphorus_mg_l) 
      ) |>
      filter(
        !is.na(total_suspended_solids_mg_l) &
        !is.na(dissolved_organic_carbon_mg_l) &
        !is.na(pH)    
      ) |> 
      mutate(
        site_id = paste(station_code, date_interval, sep=":")
      ) 
    ```

7.  Prepare Water Quality matrix

    ```{r}
    stations_with_analytes |> group_by(station_code) |> 
      summarise(
        count = n()
        )
    multivariate_df = stations_with_analytes |>
      select(
        site_id, last_fire_distance, time_since_last_fire, elevation, dissolved_organic_carbon_mg_l, pH, total_suspended_solids_mg_l 
      )

    multivariate_matrix = as.matrix(multivariate_df[5:ncol(multivariate_df)])

    rownames(multivariate_matrix) = multivariate_df$site_id
    ```

## PCO

```{r}
library(vegan)
library(factoextra)


# Way to do it so you can get eigenvalues/goodness of fit
wq_distance <- vegdist(multivariate_matrix, method = "bray")

wq_pco = cmdscale(wq_distance, k = 3, eig = TRUE)

stations_with_pco = data.frame(scores(wq_pco)) |> 
  mutate(site_id = rownames(scores(wq_pco))) |>
  inner_join(stations_with_analytes, by = join_by(site_id))

ggplot(stations_with_pco) + 
  aes(x = Dim1, y = Dim2, color = time_since_last_fire) + 
  geom_point()

ggplot(stations_with_pco) + 
  aes(x = Dim1, y = Dim2, color = last_fire_distance) + 
  geom_point()

```

## PCA

```{r}
results_pca = prcomp(multivariate_matrix, scale = TRUE)

fviz_eig(results_pca)

fviz_pca_biplot(results_pca,
                label="var",
                col.ind = as.numeric(multivariate_df$time_since_last_fire, "days"))

fviz_pca_biplot(results_pca,
                label="var",
                col.ind = multivariate_df$last_fire_distance)

fviz_pca_var(results_pca,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
             )
```

```{r}
library(ggfortify)

pca_plot_data = multivariate_df |> mutate(
  fire_distance_category = case_when(
    last_fire_distance < 500 ~ 'near',
    last_fire_distance > 500 & last_fire_distance < 1000 ~ 'mid',
    .default = 'far'
  )
)

autoplot(results_pca, data = pca_plot_data, color = 'fire_distance_category', loadings = TRUE)

autoplot(results_pca, data = pca_plot_data, color = 'time_since_last_fire', loadings = TRUE, loadings.label = TRUE)

autoplot(results_pca, data = pca_plot_data, color = 'elevation', loadings = TRUE, loadings.label = TRUE)
```

```{r}
adonis2(
  vegdist(multivariate_matrix, method = "bray") ~ last_fire_distance * time_since_last_fire * elevation, data = multivariate_df
  )

adonis2(
  vegdist(multivariate_matrix, method = "bray") ~ last_fire_distance + time_since_last_fire + elevation, data = multivariate_df
)

adonis2(
  vegdist(multivariate_matrix, method = "bray") ~ last_fire_distance + time_since_last_fire, data = multivariate_df
)
```

## NMDS

```{r}
nmds = metaMDS(multivariate_matrix, distance = "bray")
nmds_env = multivariate_df |> select(last_fire_distance, time_since_last_fire, elevation )
en = envfit(nmds, nmds_env, permutations = 999, na.rm = TRUE)

en
```

## 2d Confidence Check

```{r}

library(gridExtra)
pH_time = ggplot(multivariate_df, aes(y = pH, x = time_since_last_fire)) +
  geom_point()

pH_distance = ggplot(multivariate_df, aes(y = pH, x = last_fire_distance)) +
  geom_point()

pH_elevation = ggplot(multivariate_df, aes(y = pH, x = elevation)) +
  geom_point()

carbon_time = ggplot(multivariate_df, aes(y = dissolved_organic_carbon_mg_l, x = time_since_last_fire)) +
  geom_point()

carbon_distance = ggplot(multivariate_df, aes(y = dissolved_organic_carbon_mg_l, x = last_fire_distance)) +
  geom_point()

carbon_elevation = ggplot(multivariate_df, aes(y = dissolved_organic_carbon_mg_l, x = elevation)) +
  geom_point()

tss_time = ggplot(multivariate_df, aes(y = total_suspended_solids_mg_l, x = as.numeric(time_since_last_fire, "days"))) +
  geom_point()

tss_distance = ggplot(multivariate_df, aes(y = total_suspended_solids_mg_l, x = last_fire_distance)) +
  geom_point()

tss_elevation = ggplot(multivariate_df, aes(y = total_suspended_solids_mg_l, x = elevation)) +
  geom_point()

grid.arrange(pH_time, pH_distance, pH_elevation, 
             carbon_time, carbon_distance, carbon_elevation,
             tss_time, tss_distance, tss_elevation,
             
             ncol = 3)

```

## 

Jazzmyn

-   units and

-   Viewing the analyte data in a better way

    -   

1.  NMDS - environment variables, incorporate time
2.  Time replicates of stations HOW
