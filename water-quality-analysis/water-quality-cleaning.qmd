---
title: "Water Quality Cleaning"
author: "Sully Riley"
format: html
editor: visual
---

### Import Libraries

```{r}
library(tidyverse)
library(assertthat)

source("utils.R")
```

## Import Data

```{r}
RAW_DATA_FILE_PATH = "water-quality-raw/"
SHOULD_RUN_ASSERTIONS = T
SHOULD_FILTER_ALL_WQ = T

assert = function(assertion, msg = msg) {
  if(SHOULD_RUN_ASSERTIONS) {
    assert_that(
      assertion,
      msg = msg
    )
  }
}
```

### Water Stations

```{r}
water_stations_raw = readxl::read_excel(paste(RAW_DATA_FILE_PATH, 'WaterStationSites-3-5-24.xlsx', sep = ''))

water_stations = water_stations_raw |> 
  # rename all the columns used for analysis
  rename(
    station_code = `StationCode`,
    fire_start = `ALARM_DATE`, 
    fire_contained = `CONT_DATE`, 
    fire_name = `FIRE_NAME`,
    fire_distance = `FireDistance`
) |> 
  mutate(
    fire_start = ymd(fire_start),
    fire_contained = ymd(fire_contained)
  ) 
```

### Water Quality

```{r}
water_quality_raw = read_tsv(paste(RAW_DATA_FILE_PATH, "analytes.tsv", sep = ''))

water_quality = water_quality_raw |> rename(
  # rename all the columns used for analysis
  station_code = `StationCode`, 
  analyte = `Analyte`,             
  unit = `Unit`,           
  result = `Result`,        
  sample_date = `SampleDate`, 
  collection_time = `CollectionTime`, 
  ) |>  
  mutate(sample_date_time = mdy_hms(sample_date))

hour(water_quality$sample_date_time) = hour(mdy_hms(water_quality$collection_time))
minute(water_quality$sample_date_time) = minute(mdy_hms(water_quality$collection_time))
second(water_quality$sample_date_time) = second(mdy_hms(water_quality$collection_time))

water_quality = water_quality |> 
  select(-c(sample_date, collection_time))

```

## Clean Data

1.  Get only water quality for appropriate stations

```{r}
water_quality = water_quality |> 
  filter(station_code %in% water_stations$station_code)
```

2.  Inspect differences in units

```{r}
water_quality |> group_by(analyte, unit) |> 
  summarise(
    count = n()
  )
```

3.  There are only 29 of 3135 phosphorus measurements that are not mg/L, and since it is dry weight, we can't easily convert, so we'll drop the measurements that are not m/L

```{r}
water_quality = water_quality |> 
  # drop inorganic nitrogen
  filter(analyte != "Nitrogen, Inorganic, Total") |> 
  
  # drop phosphorus with uncommon units
  filter(!(analyte == "Phosphorus as P, Total" & unit != "mg/L")
  )
```

4.  Get selected analytes names

```{r}
analytes_of_interest = water_quality$analyte |> unique()
```

## Create sets of analytes

1.  Create a site-interval with the desired time interval

```{r}
start_date = min(water_quality$sample_date_time)
end_date = max(water_quality$sample_date_time)
  
create_date_dataframe = function(date_interval, start_date, end_date) {
  day_interval = interval(start_date,end_date)/date_interval
  dates = start_date + 0:day_interval*date_interval
  next_date = dates + date_interval

  
  date_df = as.data.frame(dates) |> 
    rename(interval_start = dates) |> 
    mutate(interval_start = as.Date(interval_start),
           interval_end = as.Date(next_date)) |> 
    mutate(date_interval = interval(interval_start, interval_end)) 
  
  date_df
}

dates = create_date_dataframe(dmonths(3), start_date, end_date)

station_codes = water_stations |> select(c(station_code)) |> 
  unique()

water_station_intervals = tidyr::crossing(station_codes, dates)
```

2.  Use a rolling join to join water quality with most recent fire

```{r}
map_analyte_to_most_recent_fire = function(water_quality, water_stations) {
  analytes_with_most_recent_fire = inner_join(
    water_quality |> 
      select(station_code, analyte, unit, sample_date_time, result),
    water_stations |> 
      select(station_code, fire_name, fire_start, fire_contained),
    by = join_by(
      station_code,
      closest(sample_date_time >= fire_start)
    )
  ) |> mutate(
    time_since_last_fire = case_when(
      sample_date_time >= fire_contained ~ as.Date(sample_date_time) - fire_contained,
      sample_date_time < fire_contained ~ ddays(0)
    )
  )
  
  analytes_with_most_recent_fire |> 
    rename(
      sample.previous_fire_name = fire_name,
      sample.previous_fire_start = fire_start,
      sample.previous_fire_contained = fire_contained,
      sample.duration_since_last_fire = time_since_last_fire
    )
}

water_quality_with_most_recent_fire = map_analyte_to_most_recent_fire(water_quality, water_stations)
```

3.  rolling join to match water_station interval with most recent fire

```{r}

water_stations_with_recent_fire = inner_join(
    water_station_intervals,
    water_stations,
    by = join_by(
      station_code,
      # can get two dates if a fire has the same start day
      closest(interval_start >= fire_start)
    )
  ) |> rename(
    site_interval.previous_fire_start = fire_start,
    site_interval.previous_fire_name = fire_name,
    site_interval.previous_fire_contained = fire_contained
  )
```

4.  match water quality measurement with water station / interval. If the water quality measurement has a most recent fire that is more recent than the interval start, set the interval start for that row to the most recent fire, and treat it as a different interval

```{r}
water_quality_for_observation = inner_join(
  water_quality_with_most_recent_fire,
  water_stations_with_recent_fire,
  by = join_by(
    station_code,
    closest(sample_date_time >= interval_start)
  )
) |> 
  # Create a new interval when the sample previous fire date is different from the site previous fire date - this happens if there was a fire since the interval started
  mutate(
  interval_start = case_when(
    site_interval.previous_fire_start != sample.previous_fire_start ~ sample.previous_fire_start,
    .default = interval_start
  ),
  site_interval.previous_fire_start = case_when(
    site_interval.previous_fire_start != sample.previous_fire_start ~ sample.previous_fire_start,
    .default = site_interval.previous_fire_start
  )
)

```

5.  Get average analyte per interval
    -   Station code
    -   interval_start
    -   analyte

```{r}
group_water_quality_by = function(water_quality_for_observation) {
  water_quality_for_observation |> 
    group_by(
      station_code,
      date_interval,
      interval_start,
      analyte,
      unit,
    )
}

assert(water_quality_for_observation |> 
  group_by(
    station_code, 
    date_interval, 
    interval_start,
    analyte,
  ) |> n_groups() == water_quality_for_observation |> 
  group_water_quality_by() |> n_groups())



mean_water_quality_for_observation = water_quality_for_observation |> 
  # dropped the ones that are after the interval start for now
  filter(interval_start == int_start(date_interval)) |> 
  group_water_quality_by() |> 
  summarise(
    result = mean(result),
    last_fire_start = unique(site_interval.previous_fire_start),
    last_fire_contained = max(site_interval.previous_fire_contained),
    last_fire_distance = min(fire_distance)
  ) |> ungroup() |> 
  mutate(
    time_since_last_fire = case_when(
      interval_start > last_fire_contained ~ interval_start - last_fire_contained,
      .default = ddays(0)
    )
  )

stations_with_analytes = mean_water_quality_for_observation |> 
  pivot_wider(
    id_cols = c(
      station_code, 
      date_interval, 
      interval_start, 
      last_fire_start, 
      last_fire_contained, 
      time_since_last_fire,
      last_fire_distance),
    names_from = analyte,
    values_from = result) |> 
  rename(
    phosphorus_mg_l = "Phosphorus as P, Total",
    dissolved_organic_carbon_mg_l = "Dissolved Organic Carbon, Dissolved",
    total_suspended_solids_mg_l = "Total Suspended Solids, Total",
    nitrogen_organic_mg_l = "Nitrogen, Organic, Total"
  ) |> select(
    -c(nitrogen_organic_mg_l, phosphorus_mg_l) 
  ) |>
  filter(
    !is.na(total_suspended_solids_mg_l) &
    !is.na(dissolved_organic_carbon_mg_l) &
    !is.na(pH)    
    ) 
```

1.  Tweak: Fire cutoff?

```{r}
multivariate_df = stations_with_analytes |> 
  mutate(
    site_id = paste(station_code, date_interval, sep=":")
    ) |> 
  select(
    site_id, last_fire_distance, time_since_last_fire, dissolved_organic_carbon_mg_l, pH, total_suspended_solids_mg_l 
  )

multivariate_matrix = as.matrix(multivariate_df[2:ncol(multivariate_df)])

nrow(multivariate_matrix)
rownames(multivariate_matrix) = multivariate_df$site_id

```

## PCA

```{r}
library(vegan)
library(factoextra)


# Way to do it so you can get eigenvalues/goodness of fit
results_distance <- vegdist(multivariate_matrix, method = "euclidean")

results_pca = prcomp(multivariate_matrix, scale = TRUE)

fviz_eig(results_pca)

fviz_pca_ind(results_pca)

fviz_pca_ind(
  results_pca, 
  axes = c(1, 2), # change which PCA axes you're viewing here
             
  col.ind = "cos2", # Color by the quality of representation
             
  gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             
  repel = TRUE     # Avoid text overlapping
)
```

Jazzmyn

-   units and

-   Viewing the analyte data in a better way

    -   

1.  NMDS - environment variables, incorporate time
2.  Time replicates of stations HOW
